Λειτουργικά Συστήματα Άρτιοι
Χειμώνας 2023
Απόστολος Κουκουβίνης
1115202000098

Κάποιες αρχικές συμβάσεις για την καλύτερη κατανόηση του προγράμματος είναι : μόνο η ρίζα ανοίγει το αρχείο και έπειτα
το κάθες παιδί της, έχοντας τον file descriptor του αρχείου, μπορεί να  διαβάσει μέσω της pread χωρίς race condition.
Οι mergers και οι sorters, είναι ξεχωριστά εκτελέσιμα που έχουν κληθεί από την ρίζα και τους mergers αντίστοιχα. Σε κάθε
τέτοια βήμα δημιουργόυνται τα κατάλληλα pipes για το stdin και το stdout των εκτελέσιμων. Οι mergers και οι sorters 
διαβάζουν τον file descriptor, την θέση στο αχείο της πρώτης εγγραφής που πρέπει να ταξινομήσουν, την θέση της τελευταίας
εγγραφής που πρέπει να ταξινομήσουν, ενώ επιπροσθέτως οι mergers διαβάζουν και το πλήθος των παιδιών. Τα ονόμα των 
εκτελέσιμων περνιούνται σαν όρισμα στην λίστα της execvp. Ακόμη, εκτός από το signal που στέλνει το κάθε παιδί όταν 
τελειώσει, γράφει μια ειδική εγγραφή στο αρχείο με id = -666, της οποίας το FirstName αντιστοιχεί στο RealTime που 
χρειάστηκε το εκάστοτες φύλλο για την ταξινόμηση, και το LastName στον CPUTime. Έτσι, η διεργασία ρίζα μπορεί να καταλάβει
ότι τελειώσαν οι εγγραφές από τους mergers, και ανάλογα ποιος merger είναι να διαβάσει και να εκτυπώσει τις ειδικές αυτές 
εγγραφές. Αν είναι ο πρώτος merger θα διαβάσει k ειδικές εγγραφές που αντιστοιχόυν στα k φύλλλα του, αν είναι ο δεύτερος,
k-1, τρίτος k-2 κ.ο.κ. Για γρήγορη ταξινόμηση έχω επιλέξει τους αλγορίθμους MergeSort και QuickSort που για τον έλεγχο
χρησιμοποιούν μια ειδική συνάρτηση που παίρνει σαν όρισμα δύο struct τύπου MyRecord και επιστρέφει έναν ακέραιο ανάλογα
με το ποιο είναι πιο "μεγάλο", όπως περιγράφεται στην εκφώνηση, στην λογική της strcmp.


Το πρόγραμμα ρίζα είναι το coordinator.cpp, το πρόγραμμα αυτό θα δημιουργήσει Κ το πλήθος mergers, και για κάθε merger
θα δημιουργήσει 2 pipes, ένα για διάβασμα από την ρίζα και ένα για διάβασμα από τον merger. Αφού η διεργασία γονιός 
γράψει σε κάθε παιδί τα απραίτητα input στο pipe που αντιστοιχεί στο νέο stdin του εκάστοτε παιδιού, η διεργασά γονιός
πρέπει να διαβάσει τα αποτελέσματα του κάθε παιδιού και έπειτα να ταξινομήσει τις εγγραφές. Για να το πετύχει αυτό η 
τεχνική που χρησιμοποιείται είναι αυτή που κάνει σε κάθε βημα merging η MergeSort, μόνο που τώρα δεν έχουμε κάνει split κατά 2 το δένδρο που 
δημιουργείται, αλλά κατά k που είναι το πλήθος των διεργασιών παιδί. Δηλαδή, η διεργασία γονιός διαλέγει σε κάθε βήμα 
το "μεγλαυτερο" από τα αποτελέσματα που του επιστρέφουν τα παιδιά και το γραφει σαν αποτέλεσμα του. Για να το πετύχει 
αυτό μπορεί αρχικά διαβάζει από το κάθε παιδί, ξεκινώντας από το παιδί 0 μέχρι το Κ - 1, όλα τα αποτέλεσματα. Αυτό έχει μια 
έξτρα χωρική πολυπλοκότητα καθώς πρέπει να κρατά έναν πίνακα για τα αποτελέσματα του κάθε παιδιού. Ακόμη, τα 
αποτελέσματα του κάθε παιδιού δεν καταναλώνονται ακριβώς ταυτόχρονα από τον γονέα, αφού πρώτα καταναλώνονται τα 
αποτελέσματα του παιδιού 0, μετά του 1 κ.ο.κ. Μια άλλη προσέγγιση θα ήταν να μην διαβάζει κατεθείαν όλα τα αποτελέσματα
του κάθε παιδιού αλλά κάθε φορά ένα partion αυτού, που με τις τεχνικές που έχουμε διδαχθεί μάλλον πάλι χάνεται η 
ταυτοχρονία και είναι μια πολύ πιο αργή τεχνική. Μια τελευταία εναλλακτική θα ήταν να μην διαβάζει τα αποτελέσματα 
κατεθείαν από το κάθε pipe, αλλά να ξεκινάει διαβάζοντας το πρώτο αποτέλεσμα από κάθε παιδί, και έπειτα να τα συγκρίνει,
να παίρνει το μεγαλύτερο από αυτά, και να διαβάζει από το αντίστοιχο pipe, μέχρι να διαβαστούν όλα τα αποτελέσματα.
Αυτή θα ήταν μια προσέγγιση πιο κοντά στην ταυτόχρονη εκτέλεση. Οπότε, χρησιμοποιώ κατά βάσει την τελευταία εκδοχή, 
ωστόσο υπάρχει και η πρώτη τεχνική σαν σχόλια, που την κράτησα γιατί είναι ιδιαίτερα ανταγωνιστική σε θέμα χρόνου. 
Σημειώνουμε επίσης ότι το id εγγραφής ίσο με -666 δηλώνει το τέλος των αποτελεσμάτων από το εκάστοτε pipe, και στις 
τιμές για το LastName και το FirstName, περιέχεται το run time και το cpu time του κάθε φύλλου αντίστοιχα. Σημειώνεται
ότι για το i παιδί έχουμε k-i αποτελέσματα παραπάνω, που αντιστοιχόυν στο προσήκον πλήθος φύλλων του κάθε παιδιού. To 
αρχείο mergers.cpp διαβάζει από το stdin ό,τι χρειάζεται και δημιουργεί τον κατάλληλο αριθμό pipes. Ρίχνοντας κέρμα 
διαλέγει μία από τις μεθόδους ταξινόμησης σαν αρχική και μετά τις εναλλάσει. Αφού εκτελέσει fork και ελέγξει ότι βρίσκεται
στην διαδικασία παιδί, μέσω exec καλεί το εκτελέσιμο του Sorter. Το αρχείο για τους sorters είναι αρκετά απλό : διαβάζει
τα pid,FileDescriptor,FirstRecord,LastRecord από το stdin και μετά κάνει exec το εκτελέσιμο που του έχει περαστεί σαν όρισμα.
Σημειώνεται εδώ ότι το pid είναι το process id της ρίζας, ώστε να μπορούν οι mergers και οι sorters να στείλουν απευθείας 
ένα signal στην ρίζα, όπου έχει οριστεί ένας handler, ώστε αυξάνοντας δυο counters να κρατά τον συνολικό αριθμό σημάτων που δέχεται
Οι MergeSort και QuickSort είναι απλές υλποιήσεις του αλγορίθμου, μόνο που στο βήμα της σύγκρισης χρησιμοποιείται η 
int RecordStrCmp(MyRecord A, MyRecord B), η οποία ορίζεται στο αρχείο utils, εκεί ορίζεται μάλιστα και η κλάση MyRecord. 
Οι τελευταίες, απλά ελέγχουν αν το DataSize είναι θετικό και προχωρούν στο δίαβασμα μέσω της pread των εγγραφών, 
αποθηκεύουν ό,τι διαβάζουν σε κατάλληλο πίνακα, τον ταξινομούν και επιστρέφουν μια μια τις ταξινομημένες εγγραφές μέσω 
του pipe-stdout. Για την εμφάνιση των χρόνων εκτέλεσης, χρησιμοποιείται η σύμβαση ότι το φύλλο 0 είναι το αριστερότερο
φύλλο του δένδρου εκτέλεσης, το αμέσως δεξιά του είναι το 1 κ.ο.κ. Σημειώνεται ότι δεν υπάρχει εγγύηση για το αν θα φτάσουν
όλα τα σήματα στην ρίζα, μπορεί κάποια να συμπίψουν χρονικά και ο kernel να μεταφέρει μόνο το ένα. Τέλος, τα εκτελέσιμα - binary
αρχεία που δημιουργούνται για την ταξινόμηση είναι τα MergeSort, QuickSort, οπότε μια πιθανή εκτέλεση του προγράμματος είναι: 
./mysort -i voters100000.bin -e2 ./MergeSort -k 4 -e1 ./QuickSort

Δεν υπάρχουν memory leaks και επιτρέπεται το Seperate Compilation.
Για την δημιουργία της ιεραρχίας των εκτελέσιμων αρκεί η εντολή make στο tty.
Με την make clean διαγράφονται όλα τα εκτελέσιμα.
Η εκτέλεση γίνεται όπως ζητείται στην εκφώνηση της εργασίας.
